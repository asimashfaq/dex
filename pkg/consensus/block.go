package consensus

import (
	"fmt"

	"github.com/dfinity/go-dfinity-crypto/bls"
	"github.com/ethereum/go-ethereum/rlp"
)

const (
	addrBytes = 20
)

var ZeroAddr = Addr{}

// Addr is the address of an account.
type Addr [addrBytes]byte

func (a Addr) String() string {
	return fmt.Sprintf("%x", a[:])
}

func (a Addr) Hex() string {
	return fmt.Sprintf("%x", a[:])
}

// ID returns the ID associated with this address.
func (a Addr) ID() bls.ID {
	var fr bls.Fr
	fr.SetHashOf(a[:])
	var id bls.ID
	err := id.SetLittleEndian(fr.Serialize())
	if err != nil {
		// should not happen
		panic(err)
	}

	return id
}

// RandVal is a random value produced by the random beacon.
//
// It is the hash of the random beacon committee group signature.
type RandVal Hash

// RandBeaconSig is the random beacon signature produced by the random
// beacon committe.
type RandBeaconSig struct {
	Round       uint64
	LastSigHash Hash
	Sig         Sig
}

// Encode encodes the random beacon signature.
func (r *RandBeaconSig) Encode(withSig bool) []byte {
	en := *r
	if !withSig {
		en.Sig = nil
	}

	b, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return b
}

// Hash returns the hash of the random beacon signature.
func (r *RandBeaconSig) Hash() Hash {
	return SHA3(r.Encode(true))
}

// RandBeaconSigShare is one share of the random beacon signature.
type RandBeaconSigShare struct {
	Owner       Addr
	Round       uint64
	LastSigHash Hash
	Share       Sig
	OwnerSig    Sig
}

// Encode encodes the random beacon signature share.
func (r *RandBeaconSigShare) Encode(withSig bool) []byte {
	en := *r
	if !withSig {
		en.OwnerSig = nil
	}

	b, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return b
}

// Hash returns the hash of the random beacon signature share.
func (r *RandBeaconSigShare) Hash() Hash {
	return SHA3(r.Encode(true))
}

// ShardNtShare is the notarization share for the shard block proposal.
type ShardNtShare struct {
	Round    uint64
	BP       Hash
	SigShare Sig
	Owner    Addr
	Sig      Sig
}

// Encode encodes the notarization share.
func (n *ShardNtShare) Encode(withSig bool) []byte {
	en := *n
	if !withSig {
		en.Sig = nil
	}

	b, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return b
}

// Hash returns the hash of the notarization share.
func (n *ShardNtShare) Hash() Hash {
	return SHA3(n.Encode(true))
}

// ShardBlockProposal is a proposal for the shard block.
type ShardBlockProposal struct {
	ShardIdx  uint16
	Round     uint64
	PrevBlock Hash
	Txns      []byte
	Owner     Addr
	// The signature of the gob serialized BlockProposal with
	// OwnerSig set to nil.
	OwnerSig Sig
}

// Encode encodes the block proposal.
func (bp *ShardBlockProposal) Encode(withSig bool) []byte {
	en := *bp
	if !withSig {
		en.OwnerSig = nil
	}

	b, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return b
}

// Hash returns the hash of the block proposal.
func (bp *ShardBlockProposal) Hash() Hash {
	return SHA3(bp.Encode(true))
}

type Genesis struct {
	Block Block
	State TrieBlob
}

// ShardBlock is the block generated by the shard notary group, shard
// blocks from all shards will be merged into a block by the global
// notary group.
type ShardBlock struct {
	ShardIdx     uint16
	Owner        Addr
	Round        uint64
	Txns         []byte
	PrevBlock    Hash
	Notarization Sig
}

// Encode encodes the shard block.
func (b *ShardBlock) Encode(withSig bool) []byte {
	en := *b
	if !withSig {
		en.Notarization = nil
	}

	d, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return d
}

// Hash returns the hash of the shard block.
func (b *ShardBlock) Hash() Hash {
	return SHA3(b.Encode(true))
}

// Block is generated from the shard blocks by global notary group.
type Block struct {
	Round       uint64
	StateRoot   Hash
	ShardBlocks []Hash
	PrevBlock   Hash
	SysTxns     []SysTxn
	// The signature of the gob serialized block with
	// Notarization set to nil.
	Notarization Sig
}

// Encode encodes the block.
func (b *Block) Encode(withSig bool) []byte {
	en := *b
	if !withSig {
		en.Notarization = nil
	}

	d, err := rlp.EncodeToBytes(en)
	if err != nil {
		panic(err)
	}

	return d
}

// Hash returns the hash of the block.
func (b *Block) Hash() Hash {
	return SHA3(b.Encode(true))
}
