package consensus

import (
	"fmt"
	"math/big"

	"github.com/dfinity/go-dfinity-crypto/bls"
)

func init() {
	err := bls.Init(int(bls.CurveFp254BNb))
	if err != nil {
		panic(fmt.Errorf("failed to init BLS library: %v", err))
	}
}

// Rand is a random value created from a hash.
type Rand Hash

// Derive derives randomness hierarchically.
func (r Rand) Derive(x ...[]byte) Rand {
	rand := r
	for _, e := range x {
		rand = Rand(SHA3(rand[:], e))
	}
	return rand
}

// Mod return rand as integer modulo n.
func (r Rand) Mod(n int) int {
	var b big.Int
	b.SetBytes(r[:])
	b.Mod(&b, big.NewInt(int64(n)))
	return int(b.Int64())
}

// Perm returns a permutation deterministically derived from rand.
func (r Rand) Perm(k, n int) []int {
	l := make([]int, n)
	for i := range l {
		l[i] = i
	}

	r1 := r
	for i := 0; i < k; i++ {
		b := []byte(fmt.Sprintf("%d", i))
		r1 = r1.Derive(b)
		j := r1.Mod(n-i) + i
		l[i], l[j] = l[j], l[i]
	}

	return l[:k]
}

// SK returns the secret key generated by hashing rand to the secret
// key finite field.
func (r Rand) SK() SK {
	var fr bls.Fr
	fr.SetHashOf(r[:])
	var sk bls.SecretKey
	err := sk.SetLittleEndian(fr.Serialize())
	if err != nil {
		// should not happen
		panic(err)
	}

	return SK(sk.GetLittleEndian())
}
